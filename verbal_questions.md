#### 1. Какой самый эффективный способ конкатенации строк?  
Сколько-то зависит от вида задачи, иногда это и обычный join сделает хорошо. Но вообще **`strings.Builder`** с заранее выделенной памятью через метод `.Grow` 
#### 2. Что такое интерфейсы, как они применяются в Go?  
Интерфейс — инструмент, который позволяет определять контракты, которым должны соблюдать структуры или другие типы. Они определяют набор методов который должна реализовывать структура.
Зачем? 
- Абстрагирование — детали реализации не так важны, главное как с этой сущностью можно взаимодействовать. Напрмер у меня в L0 бд и бд с кешем реализуют один интерфейс бд. То есть тому кто с ней взаимодействует вообще не важно как она внутри устроена и откуда берет значения из бд, или из кеша и иногда из бд, главное что можно сделать селект, инсерт и т.д
- Мокирование, в тестах можно писать мок-версии сложных объектов, чтобы упростить тестирование функций, которые их используют.

Ну и вообще это такой способ компилятору и IDE, что мы собираемся оперировать объектами, у которых можно будет впоследствии вызвать какие-то методы

#### 3. Чем отличаются RWMutex от Mutex?  

Mutex — это примитив синхронизации, который позволяет защитить доступ к критической секции кода. Он гарантирует, что только одна горутина может захватить (lock) мьютекс в данный момент времени. Как только мьютекс захвачен одной горутиной, любые другие горутины, пытающиеся захватить этот мьютекс, будут блокироваться до тех пор, пока он не будет освобождён (unlock) первой горутиной. Это включает в себя любые операции — и чтение, и запись.

RWMutex — это специализированная форма мьютекса, которая позволяет более тонкую настройку управления доступом:

- Множество горутин могут одновременно захватывать мьютекс для операций **чтения** (lock для чтения, или RLock).
- Только одна горутина может захватить мьютекс для операции **записи** (lock для записи).

Ключевое различие здесь в том, что при захваченном для чтения мьютексе новые операции чтения могут начаться даже при уже захваченном мьютексе, пока не начнётся операция записи. Операция записи должна дождаться, когда все чтения завершатся (и другие операции записи не активны), прежде чем она может начаться.

#### 4. Чем отличаются буферизированные и не буферизированные каналы?  

Каналы это примитив синхронизации который позволяет обмениваться данными между потоками. Реализует принцип FIFO. 

Его можно представить как очередь размера n, в которую можно что-то положить и что-то взять. Особенности канала таковы, что чтение из пустого канала и запись в полный — блокирующая операция. Соответственно чтение в такой момент разблокируется когда в канал что-то положат, а запись, если что-то заберут.

Небуферизированный это как канал, где n = 0. Канал отличается тем, что она всегда и полон и пуст одновременно. То есть операция чтения ЛИБО операция записи все заблокирует, но если они будут ожидать друг друга в разных горутинах, то они разблокируются и передадут данные друг другу. 

#### 5. Какой размер у структуры struct{}{}?  

0 байт

#### 6. Есть ли в Go перегрузка методов или операторов?  

Не поддерживается, перегрузка методов или операторов. Это сознательное решение разработчиков языка, для упрощения и читаемости кода.

7. В какой последовательности будут выведены элементы map[int]int?

Смотря как выводить. fmt.Print сортирует внутри ключи перед выводом 

Если обходить ключи, то случайно т.к там прям в коде функция рандом используется.

#### 8. В чем разница make и new?
Функция `new(T)` выделяет память для нового элемента типа `T` и возвращает указатель на неинициализированное значение этого типа, т.е., все поля инициализированы нулевыми значениями для данного типа. Она применяется к любому типу данных.

Функция `make` используется для аллокации и инициализации исключительно слайсов, мап и каналов. Она возвращает инициализированный (не нулевой) экземпляр типа, а не указатель. и там ещё есть кастомные параметры типо len и capacity 

`new` не инициализирует память, кроме установки нулевых значений, тогда как `make` также инициализирует структуры данных, что делает их готовыми к использованию 
(например, слайсы с заданной длиной и емкостью).

`new` возвращает указатель на тип (например, `*T`), `make` возвращает инициализированный экземпляр типа напрямую.

#### 9. Сколько существует способов задать переменную типа slice или map?
```go
// С помощью make
s1 := make([]int, 5)

// С помощью литерала
s2 := []int{1, 2, 3}

// Подмножество массива
arr := [5]int{1, 2, 3, 4, 5}
s3 := arr[1:4]

// Nil слайс
var s4 []int
```

```go
// С помощью make
m1 := make(map[string]int)

// С помощью литерала
m2 := map[string]int{"one": 1, "two": 2}

// Nil карта
var m3 map[string]int
```

#### 10. Что выведет данная программа и почему? 
```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )

  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
///////////////////////
1
1
```



Внутри функции `update`:
- Создаётся новая переменная `b` со значением `2`.
- Переменной `p` (которая является копией изначального указателя `p`) присваивается адрес новой переменной `b`.
- Это изменение не влияет на изначальный указатель `p` в функции `main`, так как `update` работает с копией этого указателя. Изменения внутри `update` не видны за пределами функции.


#### 11. Что выведет данная программа и почему?  
```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
////////

// Ничего? Мы застрянем на wg.Wait()
```

Ошибка здесь в том, что `sync.WaitGroup` передается по значению, а не по ссылке. `sync.WaitGroup` должен передаваться по ссылке, чтобы горутины могли сигнализировать о завершении работы в один и тот же объект `sync.WaitGroup`.

#### 12. Что выведет данная программа и почему?  
```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
////////////
0

```

используется `:=`, что приводит к созданию новой локальной переменной `n` в области видимости блока `if`. Эта новая переменная `n` существует только внутри этого блока `if`.

#### 13. Что выведет данная программа и почему?  
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

////////
[100 2 3 4 5]
```

100 появится потому что они ссылаются на один базовый массив, а хоть слайс и передается по значению — внутри все равно имеет ссылку на базовый массив.

А элемент не добавится потому что при превышении капасити произойдет алокация

#### 14. Что выведет данная программа и почему?  

```go
func main() {
  slice := []string{"a", "a"}
  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  
  fmt.Print(slice)
} 

/////

`[b b a][a a]`
```

В анонимной функции при превышении капасити память алоцируется и мы не изменим базовый массив, поэтому значения слайс в main не изменяться